#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <time.h>
#define V 7
#define INF 99999
#define D_TO_G_COST 2 
#define B_TO_G_COST 3 

struct Edge {
    int dest;
    int weight;
    struct Edge* next;
};

struct Graph {
    struct Edge* head[V];
};

struct Edge* createEdge(int dest, int weight) {
    struct Edge* newEdge = (struct Edge*)malloc(sizeof(struct Edge));
    newEdge->dest = dest;
    newEdge->weight = weight;
    newEdge->next = NULL;
    return newEdge;
}

void addEdge(struct Graph* graph, int src, int dest, int weight) {
    struct Edge* newEdge = createEdge(dest, weight);
    newEdge->next = graph->head[src];
    graph->head[src] = newEdge;
}

void updateEdgeWeight(struct Graph* graph, int src, int dest, int multiplier) {
    struct Edge* current = graph->head[src];
    int oldWeight;
    while (current != NULL) {
        if (current->dest == dest) {
            oldWeight = current->weight;
            current->weight *= multiplier;
            printf("\n[Sistem]: %c -> %c Kenar Maliyeti Guncellendi (%d -> %d)\n", 
                   'A' + src, 'A' + dest, oldWeight, current->weight);
            return;
        }
        current = current->next;
    }
}

int minDistance(int dist[], int sptSet[]) {
    int min = INF, min_index;
    int v;
    for (v = 0; v < V; v++) {
        if (sptSet[v] == 0 && dist[v] <= min) {
            min = dist[v];
            min_index = v;
        }
    }
    return min_index;
}

void printPath(int parent[], int j) {
    if (parent[j] == -1)
        return;
    printPath(parent, parent[j]);
    printf(" -> %c", 'A' + j);
}

void dijkstra(struct Graph* graph, int src, int target) {
    int dist[V];
    int sptSet[V];
    int parent[V];
    int iteration_count = 0;
    int comparison_count = 0;
    int i, count, u, v, weight;
    struct Edge* current;
    
    for (i = 0; i < V; i++) {
        dist[i] = INF;
        sptSet[i] = 0;
        parent[i] = -1;
    }
    
    dist[src] = 0;

    for (count = 0; count < V - 1; count++) {
        iteration_count++;
        
        u = minDistance(dist, sptSet);
        sptSet[u] = 1;

        current = graph->head[u];
        while (current != NULL) {
            v = current->dest;
            weight = current->weight;
            
            comparison_count++;
            if (!sptSet[v] && dist[u] != INF && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                parent[v] = u;
            }
            current = current->next;
        }
    }

    printf("\n--- Analiz Sonuclari ---\n");
    printf("Hedef (%c) Icin En Kisa Mesafe: %d\n", 'A' + target, dist[target]);
    printf("Rota: %c", 'A' + src);
    printPath(parent, target);
    printf("\n");
    printf("Iterasyon Sayisi: %d\n", iteration_count);
    printf("Karsilastirma Sayisi: %d\n", comparison_count);
}

int main() {
    struct Graph* graph;
    int i;
    clock_t start, end;
    double time_taken;

    graph = (struct Graph*)malloc(sizeof(struct Graph));
    for (i = 0; i < V; i++) graph->head[i] = NULL;

    addEdge(graph, 0, 1, 4); 
    addEdge(graph, 0, 2, 2); 
    addEdge(graph, 1, 2, 1); 
    addEdge(graph, 1, 3, 2); 
    addEdge(graph, 2, 3, 5); 
    addEdge(graph, 2, 4, 10); 
    addEdge(graph, 3, 4, 3);  
    addEdge(graph, 3, 5, 6);  
    addEdge(graph, 4, 5, 1);  
    addEdge(graph, 3, 6, D_TO_G_COST); 
    addEdge(graph, 1, 6, B_TO_G_COST); 

    printf("=== 1. CALISTIRMA (Normal Graf) ===\n");
    start = clock();
    dijkstra(graph, 0, 6); 
    end = clock();
    time_taken = ((double)(end - start)) / CLOCKS_PER_SEC;
    printf("Calisma Suresi: %f saniye\n", time_taken);

    printf("\n=== 2. CALISTIRMA (B->D Maliyeti 2 Katina Cikarildi) ===\n");
    updateEdgeWeight(graph, 1, 3, 2); 
    
    start = clock();
    dijkstra(graph, 0, 6); 
    end = clock();
    time_taken = ((double)(end - start)) / CLOCKS_PER_SEC;
    printf("Calisma Suresi: %f saniye\n", time_taken);

    return 0;
}